name = "Sean"
string = " Hello " <> name
list = ([1, 2] ++ [3, 4]) -- [1,3]
tuple = {3.14, :pie, "Apple"}
keywordlist = [{:foo, "bar"}, {:hello, "world"}]
map = %{:foo => "bar", "hello" => :world}
map2 = %{map | foo: "baz"}


#Enum.__info__(:functions) |> Enum.each(fn({function, arity}) ->
#IO.puts "#{function}/#{arity}"
#end)



IO.puts Enum.all?(["foo", "bar", "hello"], fn(s) -> String.length(s) == 3 end)

IO.puts Enum.chunk_by(["one", "two", "three", "four", "five"], fn(x) -> String.length(x) end)

IO.puts Enum.map([0, 1, 2, 3], fn(x) -> Integer.to_string(x - 1) end)

IO.puts Enum.filter([1, 2, 3, 4], fn(x) -> rem(x, 2) == 0 end)

IO.puts Enum.reduce(["a","b","c"], "1", fn(x,acc)-> x <> acc end)

list = [1, 2, 3, "test"]
[1, 2, 3 | tail] = list
IO.puts tail

greeting = "Hello"
greet = fn
   (^greeting, name) -> "Hi #{name}"
   (greeting, name) -> "#{greeting}, #{name}"
end
IO.puts greet.("Hello", "Sean")
IO.puts greet.("Mornin", "Sean")

if String.valid?("Hello") do
	IO.puts "ok"
else
	IO.puts "ko"
end

unless is_integer("hello") do
	IO.puts "not int"
end


case {:ok, "Hello World"} do
   {:ok, result} -> IO.puts result
   {:error} -> IO.puts "Uh oh!"
   _ -> IO.puts "Catch all"
 end

cond do
   7 + 1 == 0 -> IO.puts "Incorrect"
   true -> IO.puts "Catch all"
end

user = %{first: "doomspork", last: "Callan"}
 with {:ok, first} <- Map.fetch(user, :first),
    {:ok, last} <- Map.fetch(user, :last),
    do: IO.puts last <> ", " <> first

sum = &(&1 + &2)
IO.puts Integer.to_string sum.(2,3)

defmodule Greeter do
  def hello(name) do
    "Hello, " <> name
  end
end

IO.puts Greeter.hello("Sean")

defmodule Length do
  def of([]), do: 0
  def of([_ | tail]), do: 1 + of(tail)
end

IO.puts Length.of [1, 2, 3]

defmodule Greeter2 do
  def hello(name), do: phrase() <> name
  defp phrase, do: "Hello, "
end

IO.puts Greeter2.hello("Sean")

defmodule Greeter3 do
	def hello(name \\ "default")
  def hello(names) when is_list(names) do
    names
    |> Enum.join(", ")
    |> hello
  end

  def hello(name ) when is_binary(name) do
    phrase() <> name
  end

  defp phrase, do: "Hello, "
end

IO.puts Greeter3.hello ["Sean", "Steve"]
IO.puts Greeter3.hello

IO.puts "Elixir rocks" |> String.upcase() |> String.split()

defmodule Example do
  @greeting "Hello"

  def greeting(name) do
    ~s(#{@greeting} #{name}.)
  end
end

defmodule Example2.User do
  defstruct name: "Sean", roles: []
end

defmodule HelloMacro do
  defmacro __using__(opts) do
  greeting = Keyword.get(opts, :greeting, "Hi")
    quote do
      def helloMac(name), do: unquote(greeting) <> ", " <> name
    end
  end
end

defmodule MySigils do
   def sigil_u(string, []), do: String.upcase(string)
 end

import List, only: [last: 1]


re = ~r/elixir/
IO.puts "elixir" =~ re
string = "100_000_000"
IO.puts Regex.split(~r/_/, string)
IO.puts NaiveDateTime.from_iso8601("2015-01-23 23:50:07") == {:ok, ~N[2015-01-23 23:50:07]}



list = [1, 2, 3, 4, 5]
for x <- list, do: IO.puts x*x

for {k, v} <- %{"a" => "A", "b" => "B"}, do: IO.puts k

for n <- list, times <- 1..n do
	IO.puts String.duplicate("*", times)
end

import Integer
for x <- 1..10, is_even(x), do: IO.puts x

for {k, v} <- [one: 1, two: 2, three: 3], into: %{}, do: {k, v}

string = <<104,101,108,108,111>>
IO.puts string

IO.puts 'hełło'
IO.puts "hełło" <> <<0>>

IO.puts String.length "hello"
IO.puts String.replace("Hello", "e", "a")
IO.puts String.split("Hello World", " ")

defmodule Anagram do
  def anagrams?(a, b) when is_binary(a) and is_binary(b) do
    sort_string(a) == sort_string(b)
  end

  def sort_string(string) do
    string
    |> String.downcase()
    |> String.graphemes()
    |> Enum.sort()
  end
end

defmodule Main do
	@moduledoc """
  	Provides a main function
  	"""

	use HelloMacro, greeting: "Hola"
	import MySigils
	@doc """
	  Main function

	  ## Parameters

	    - none

	  ## Examples

	      iex> Main.main()
	  """
  def main do
    user = %Example2.User{name: "Steve", roles: [:admin, :owner]}
    sean = %{user | name: "Sean"}
    IO.puts sean.name
    IO.puts last(["one","two"])
    IO.puts helloMac("toto")
    IO.puts ~u/elixir school/
    IO.puts Anagram.anagrams?("Hello", "ohell")
  end
end


{time, result} = :timer.tc(fn (n) -> (n * n) * n end, [100])
IO.puts("Time: #{time} μs")
IO.puts("Result: #{result}")

try do
   raise "Oh no!"
 rescue
   e in RuntimeError -> IO.puts("An error occurred: " <> e.message)
 after
 	IO.puts "finish"
 end

defmodule MyError do
  defexception message: "an example error has occurred"
end

try do
   raise MyError
 rescue
   e in MyError -> IO.puts("An error occurred: " <> e.message)
 end

 try do
   for x <- 0..10 do
    if x == 5, do: throw(x)
     IO.puts(x)
   end
 catch
   x -> IO.puts "Caught: #{x}"
 end



mytoto = fn() -> IO.puts "simple func" end

mytoto.()

Main.main

defmodule ExConc do
  def add(a, b) do
  	IO.puts("yep")
    IO.puts(a + b)
  end
  def listen do
    receive do
      {:ok, "hello"} -> IO.puts("World")
    end

    listen
  end
end

spawn(ExConc, :add, [2, 3])

pid = spawn(ExConc, :listen, [])

send pid, {:ok, "hello"}

defmodule ExLink do
  def explode, do: exit(:kaboom)

  def run do
    Process.flag(:trap_exit, true)
    spawn_link(ExLink, :explode, [])

    receive do
      {:EXIT, from_pid, reason} -> IO.puts("Exit reason: #{reason}")
    end
  end
end

defmodule ExMonitor do
  def explode, do: exit(:kaboom)

  def run do
    {pid, ref} = spawn_monitor(ExMonitor, :explode, [])

    receive do
      {:DOWN, ref, :process, from_pid, reason} -> IO.puts("Exit reason: #{reason}")
    end
  end
end


ExLink.run
ExMonitor.run

{:ok, agent} = Agent.start_link(fn -> [1, 2, 3] end)
Agent.update(agent, fn (state) -> state ++ [4, 5] end)
IO.puts Agent.get(agent, &(&1))

Agent.start_link(fn -> [1, 2, 3] end, name: Numbers)
IO.puts Agent.get(Numbers, &(&1))

defmodule ExTask do
  def double(x) do
    :timer.sleep(2000)
    x * 2
  end
end

task = Task.async(ExTask, :double, [2000])
IO.puts Task.await(task)

spawn_link fn -> exit("oh no") end

